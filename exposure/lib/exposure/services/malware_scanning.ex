defmodule Exposure.Services.MalwareScanning do
  @moduledoc """
  Service for scanning files for malware using ClamAV.

  Requires ClamAV daemon (clamd) running on the configured host:port.
  """

  require Logger

  @type scan_result :: :clean | {:infected, String.t()} | {:error, String.t()} | :disabled

  @doc """
  Returns the current malware scanning configuration.
  """
  def config do
    Application.get_env(:exposure, :malware_scanning, default_config())
  end

  defp default_config do
    %{
      enabled: false,
      clamav: %{server: "localhost", port: 3310},
      timeout_seconds: 30,
      max_file_size_for_scan_mb: 25
    }
  end

  @doc """
  Checks if malware scanning is enabled.
  """
  def enabled? do
    config()[:enabled] == true
  end

  @doc """
  Checks if ClamAV daemon is available by sending a PING command.
  """
  def available? do
    if not enabled?() do
      false
    else
      case ping() do
        {:ok, _} -> true
        _ -> false
      end
    end
  end

  @doc """
  Pings the ClamAV daemon to check if it's responsive.
  """
  def ping do
    with_connection(fn socket ->
      :gen_tcp.send(socket, "PING\n")

      case :gen_tcp.recv(socket, 0, timeout_ms()) do
        {:ok, data} ->
          response = String.trim(to_string(data))

          if response == "PONG" do
            {:ok, "PONG"}
          else
            {:error, "Unexpected response: #{response}"}
          end

        {:error, reason} ->
          {:error, "Receive error: #{inspect(reason)}"}
      end
    end)
  end

  @doc """
  Scans file data for malware.

  Returns:
  - `:clean` - No malware detected
  - `{:infected, virus_name}` - Malware was detected
  - `{:error, reason}` - An error occurred during scanning
  - `:disabled` - Scanning is disabled
  """
  @spec scan_data(binary(), String.t()) :: scan_result()
  def scan_data(data, filename) when is_binary(data) do
    if not enabled?() do
      Logger.debug("Malware scanning is disabled")
      :disabled
    else
      file_size_mb = byte_size(data) / 1024 / 1024
      max_size = config()[:max_file_size_for_scan_mb] || 25

      if file_size_mb > max_size do
        Logger.warning(
          "File #{filename} (#{Float.round(file_size_mb, 2)} MB) exceeds max scan size (#{max_size} MB)"
        )

        {:error, "File too large for scanning"}
      else
        case available?() do
          false ->
            Logger.warning("ClamAV is not available")
            {:error, "ClamAV service is not available"}

          true ->
            do_scan(data, filename)
        end
      end
    end
  end

  @doc """
  Scans a Plug.Upload struct for malware.
  """
  @spec scan_upload(Plug.Upload.t()) :: scan_result()
  def scan_upload(%Plug.Upload{path: path, filename: filename}) do
    case File.read(path) do
      {:ok, data} ->
        scan_data(data, filename)

      {:error, reason} ->
        {:error, "Failed to read file: #{inspect(reason)}"}
    end
  end

  @doc """
  Scans multiple uploads for malware.

  Returns `{:ok, :clean}` if all files pass, or `{:error, message}` if any fail.
  """
  @spec scan_uploads([Plug.Upload.t()]) :: {:ok, :clean} | {:error, String.t()}
  def scan_uploads(uploads) when is_list(uploads) do
    if not enabled?() do
      {:ok, :clean}
    else
      results =
        Enum.map(uploads, fn upload ->
          {upload.filename, scan_upload(upload)}
        end)

      infections =
        Enum.filter(results, fn
          {_, {:infected, _}} -> true
          _ -> false
        end)
        |> Enum.map(fn {filename, {:infected, virus}} -> "#{filename}: #{virus}" end)

      if infections != [] do
        message = "Malware detected in #{length(infections)} file(s): #{Enum.join(infections, "; ")}"
        Logger.warning("Malware scan failed: #{message}")
        {:error, message}
      else
        errors =
          Enum.filter(results, fn
            {_, {:error, _}} -> true
            _ -> false
          end)
          |> Enum.map(fn {filename, {:error, err}} -> "#{filename}: #{err}" end)

        if errors != [] do
          message = "Scan errors for #{length(errors)} file(s): #{Enum.join(errors, "; ")}"
          Logger.warning("Malware scanning had errors: #{message}")
          {:error, message}
        else
          Logger.info("All files passed malware scan")
          {:ok, :clean}
        end
      end
    end
  end

  @doc """
  Gets the status of the malware scanning service.
  """
  @spec get_status() :: String.t()
  def get_status do
    if not enabled?() do
      "Malware scanning is disabled"
    else
      clamav_config = config()[:clamav] || %{}
      server = clamav_config[:server] || "localhost"
      port = clamav_config[:port] || 3310

      if available?() do
        "ClamAV is available at #{server}:#{port}"
      else
        "ClamAV is NOT available at #{server}:#{port}"
      end
    end
  end

  # Private functions

  defp do_scan(data, filename) do
    Logger.info("Scanning file #{filename} with ClamAV")

    with_connection(fn socket ->
      # Use INSTREAM command for streaming data
      # Format: zINSTREAM\0 + (size as 4-byte big-endian) + data + (0000 to end)
      :gen_tcp.send(socket, "zINSTREAM\0")

      # Send data in chunks
      chunk_size = 1024 * 1024  # 1MB chunks
      chunks = for <<chunk::binary-size(chunk_size) <- data>>, do: chunk
      remainder = binary_part(data, div(byte_size(data), chunk_size) * chunk_size, rem(byte_size(data), chunk_size))
      all_chunks = if remainder == "", do: chunks, else: chunks ++ [remainder]

      Enum.each(all_chunks, fn chunk ->
        size = byte_size(chunk)
        :gen_tcp.send(socket, <<size::32-big>> <> chunk)
      end)

      # Send end marker (0-length chunk)
      :gen_tcp.send(socket, <<0::32-big>>)

      # Read response
      case :gen_tcp.recv(socket, 0, timeout_ms()) do
        {:ok, response_data} ->
          response = String.trim(to_string(response_data))
          parse_scan_response(response, filename)

        {:error, reason} ->
          Logger.error("ClamAV scan error for #{filename}: #{inspect(reason)}")
          {:error, "Scan error: #{inspect(reason)}"}
      end
    end)
  end

  defp parse_scan_response(response, filename) do
    cond do
      String.contains?(response, "OK") ->
        Logger.info("File #{filename} is clean")
        :clean

      String.contains?(response, "FOUND") ->
        # Extract virus name from response like "stream: Eicar-Test-Signature FOUND"
        virus_name =
          response
          |> String.replace(~r/^stream:\s*/, "")
          |> String.replace(~r/\s*FOUND\s*$/, "")
          |> String.trim()

        Logger.warning("Virus detected in #{filename}: #{virus_name}")
        {:infected, virus_name}

      String.contains?(response, "ERROR") ->
        Logger.error("ClamAV scan error for #{filename}: #{response}")
        {:error, response}

      true ->
        Logger.error("Unknown scan result for #{filename}: #{response}")
        {:error, "Unknown scan result: #{response}"}
    end
  end

  defp with_connection(fun) do
    clamav_config = config()[:clamav] || %{}
    server = clamav_config[:server] || "localhost"
    port = clamav_config[:port] || 3310

    server_charlist = String.to_charlist(server)
    opts = [:binary, active: false, packet: :raw]

    case :gen_tcp.connect(server_charlist, port, opts, timeout_ms()) do
      {:ok, socket} ->
        try do
          fun.(socket)
        after
          :gen_tcp.close(socket)
        end

      {:error, reason} ->
        Logger.error("Failed to connect to ClamAV at #{server}:#{port}: #{inspect(reason)}")
        {:error, "Connection failed: #{inspect(reason)}"}
    end
  end

  defp timeout_ms do
    (config()[:timeout_seconds] || 30) * 1000
  end
end
